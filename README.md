
# AI tolls to learn better way

![image](https://github.com/user-attachments/assets/c3e7fa38-3fb4-42ec-9ef0-11d616e6e265)

![image](https://github.com/user-attachments/assets/4054cb92-4c15-40a0-9d9b-9e4de5fcc209)

![image](https://github.com/user-attachments/assets/d15667d1-593c-4425-8310-294b3afef001)

# Algorithms Patterns

![image](https://github.com/user-attachments/assets/0c127d22-2d4c-4d42-99fa-68fac24b2c67)

![image](https://github.com/user-attachments/assets/b8da0858-bed1-4a4d-bec0-02a83fd93a1a)


Top 100 Questions -> https://instabyte.io/p/interview-master-100
-----------------

#### Topic wise Prolems:

```console
* https://algomaster.io/practice/dsa-patterns

THE ULTIMATE INTERVIEWS GUIDE
Interview Master 100

Two Sum [Solution]

Valid Parentheses [Solution]

Merge Two Sorted Lists [Solution]

Best Time to Buy and Sell Stock [Solution]

Valid Palindrome [Solution]

Invert Binary Tree

Valid Anagram

Binary Search

Linked List Cycle

Maximum Depth of Binary Tree

Single Number

Reverse Linked List

Majority Element

Missing Number

Reverse String

Diameter of Binary Tree [Solution]

Middle of the Linked List [Solution]

Convert Sorted Array to Binary Search Tree

Maximum Subarray [Solution]

Climbing Stairs [Solution]

Symmetric Tree [Solution]

Product of Array Except Self [Solution]

Best Time to Buy and Sell Stock II [Solution]

House Robber [Solution]

Number of 1 Bits

Validate Binary Search Tree

Min Stack [Solution]

Contains Duplicate [Solution]

Kth Smallest Element in a BST

Merge Intervals [Solution]

Set Matrix Zeroes [Solution]

Spiral Matrix [Solution]

3Sum [Solution]

Binary Tree Zigzag Level Order Traversal

Construct Binary Tree from Preorder and Inorder Traversal

Container With Most Water [Solution]

Flatten Binary Tree to Linked List [Solution]

Group Anagrams [Solution]

Implement Trie (Prefix Tree)

Kth Largest Element in an Array

Longest Palindromic Substring

Longest Substring Without Repeating Characters [Solution]

Maximal Square [Solution]

Maximum Product Subarray

Minimum Window Substring [Solution]

Number of Islands [Solution]

Permutations [Solution]

Remove Nth Node From End of List

Rotate Image [Solution]

Search a 2D Matrix

Search in Rotated Sorted Array

Subsets [Solution]

Top K Frequent Elements [Solution]

Trapping Rain Water

Two Sum II - Input Array Is Sorted

Unique Paths

Valid Sudoku

Word Break

Word Search

Add Two Numbers [Solution]

Basic Calculator

Coin Change

Combination Sum

Copy List with Random Pointer

Course Schedule [Solution]

Design Add and Search Words Data Structure

Merge Sorted Array

Find Median from Data Stream

Game of Life

Jump Game

Letter Combinations of a Phone Number

Longest Consecutive Sequence [Solution]

Longest Increasing Subsequence

Median of Two Sorted Arrays

Merge k Sorted Lists [Solution]

Minimum Path Sum

Word Search II

Reverse Nodes in k-Group

Course Schedule II

Remove Element

Rotate Array

Bitwise AND of Numbers Range

Palindrome Number

Plus One

Sqrt(x)

Pow(x n) [Solution]

Construct Binary Tree from Inorder and Postorder Traversal

Path Sum

Binary Tree Right Side View

Binary Tree Level Order Traversal [Solution]

Minimum Absolute Difference in BST

Surrounded Regions

Clone Graph

Evaluate Division

Generate Parentheses [Solution]

Sort List

Maximum Sum Circular Subarray

Find Peak Element

Find Minimum in Rotated Sorted Array [Solution]

Remove Duplicates from Sorted Array
```

----------------------------------------------
## THE ULTIMATE DSA GUIDE- Data Structure specific algorithms

#### 1. Arrays
 * Sorting:

    * QuickSort: Efficient average-case time complexity (O(nlog n))

    * MergeSort: Stable sort, useful when order matters (O(nlog n))

* Searching:

   * Binary Search: Fast search in sorted arrays (O(log n))

* Two Pointers:

  * In-place manipulation, often for sorted arrays (e.g., removing duplicates)

* Sliding Window:

  * Subarray problems, finding maximum/minimum within a window

#### 2. Linked Lists
* Traversal:

   * Iterate through the list, understand the node structure

* Insertion/Deletion:

   * At beginning, end, or at a specific position

* Reversal:

   * In-place reversal, recursive and iterative approaches

* Cycle Detection:

   * Floyd's Tortoise and Hare algorithm

#### 3. Hash Tables (Hash Maps/Sets)
* Implementation not needed. Just understand following:

* Understand how hash functions work

* Insertion/Deletion/Lookup

* Collision Handling

#### 4. Trees (Binary Trees, Binary Search Trees, etc.)
* Traversal:

   * Inorder, Preorder, Postorder (recursive and iterative)

* Searching:

   * Find a node with a given value (especially in BSTs)

#### 5. Stacks
* Implementation not needed. Just understand following:

   * Push/Pop/Peek Operations

#### 6. Queues
* Implementation not needed. Just understand following:

   * Enqueue/Dequeue Operations

#### 7. Heaps (Priority Queues)
* Implementation not needed. Just understand following:

   * Insertion/Deletion (extract-min/max)

   * Building a Heap

* Top K Elements:

   * Using a heap to find k largest/smallest elements

#### 8. Graphs
* Traversal:

   * Breadth-First Search (BFS)

   * Depth-First Search (DFS)

* Shortest Path:

   * Dijkstra's Algorithm

* Cycle Detection:

   * DFS

#### 9. Tries
* Implement Trie from scratch

   * Insertion/Searching:

   * For words/prefixes

* Autocompletion:

 * Using a trie for word suggestions

#### 10. Union-Find (Disjoint Set)
* Implement Union-Find from scratch

* Find/Union Operations

* Cycle Detection in undirected graphs

* General algorithms/techniques
   * 1. Recursion
     * Defining a problem in terms of itself, often leading to elegant and concise solutions.

     * Solve: Factorial calculation, tree traversals, depth-first search.

  * 2. Dynamic Programming
    * Breaking down a problem into overlapping subproblems and storing solutions to avoid recomputation.

    * Solve: Fibonacci sequence, Knapsack problem, Longest Common Subsequence.

 * 3. Greedy Algorithms
   * Making locally optimal choices at each step with the hope of finding a global optimum.

   * Implement: Kruskal's algorithm for minimum spanning trees.

 * 4. Backtracking
  * Incrementally building solutions, exploring all possible paths, and abandoning invalid ones.

Solve: Sudoku solver, N-Queens problem, generating permutations.
----------------------------------------------

# List Of Algorithms
1. Sorting Algorithms
   
    * Bubble Sort
    * Selection Sort
    * Insertion Sort
    * Merge Sort
    * Quick Sort
    * Heap Sort
    * Radix Sort
    * Counting Sort
    * Bucket Sort
    * Shell Sort
   
3. Searching Algorithms
    * Linear Search
    * Binary Search
    * Jump Search
    * Interpolation Search
    * Exponential Search
4. Graph Algorithms
    * Breadth-First Search (BFS)
    * Depth-First Search (DFS)
    * Dijkstra’s Algorithm (Shortest Path)
    * Bellman-Ford Algorithm (Shortest Path)
    * Floyd-Warshall Algorithm (All-Pairs Shortest Path)
    * Prim’s Algorithm (Minimum Spanning Tree)
    * Kruskal’s Algorithm (Minimum Spanning Tree)
    * Topological Sort
    * A Search Algorithm*
5. Dynamic Programming
    * Knapsack Problem (0/1 Knapsack, Fractional Knapsack)
    * Longest Common Subsequence (LCS)
    * Longest Increasing Subsequence (LIS)
    * Matrix Chain Multiplication
    * Fibonacci Sequence
    * Subset Sum Problem
    * Coin Change Problem
    * Rod Cutting Problem
6. String Algorithms
    * KMP Algorithm (Knuth-Morris-Pratt)
    * Rabin-Karp Algorithm
    * Boyer-Moore Algorithm
    * Z Algorithm
    * Aho-Corasick Algorithm (Multiple Pattern Searching)
    * Longest Palindromic Substring
    * String Matching/Pattern Matching
7. Divide and Conquer
    * Merge Sort
    * Quick Sort
    * Binary Search
    * Strassen’s Matrix Multiplication
8. Greedy Algorithms
    * Activity Selection Problem
    * Huffman Coding
    * Dijkstra’s Algorithm
    * Prim’s Algorithm
    * Kruskal’s Algorithm
9. Backtracking
    * N-Queens Problem
    * Sudoku Solver
    * Subset Generation
    * Word Search Problem
    * Hamiltonian Path and Cycle
10. Mathematical Algorithms
    * Greatest Common Divisor (GCD)
    * Least Common Multiple (LCM)
    * Sieve of Eratosthenes (Finding primes)
    * Modular Exponentiation
    * Fast Fourier Transform (FFT)
11. Data Structure-Specific Algorithms
    * Binary Tree Traversals (Inorder, Preorder, Postorder)
    * Level Order Traversal
    * AVL Tree Rotations
    * Union-Find (Disjoint Set)
    * Trie Insert/Search
12. Advanced Algorithms
    * Ford-Fulkerson Algorithm (Max Flow)
    * Edmonds-Karp Algorithm (Max Flow)
    * KMP Algorithm (String Matching)
    * Convex Hull Algorithm (Graham’s Scan, Jarvis March)
13. Miscellaneous Algorithms
    * Reservoir Sampling
    * Randomized Algorithms (Quickselect, Randomized QuickSort)
    * Monte Carlo and Las Vegas Algorithms
   
      
# List of Data structures

Let me explain each data structure and when to use them:

Arrays


Fixed-size collection of elements
Fast access by index
Best for: When you know the size won't change and need quick access by position
Memory efficient but inflexible


ArrayList


Dynamic-size array list
Automatically grows as needed
Best for: When you need a resizable list with fast access by index
More flexible than arrays but slightly more memory overhead


LinkedList


Doubly-linked list implementation
Fast insertion/deletion at both ends
Best for: Frequent insertions/deletions, especially at the beginning/end
Uses more memory than ArrayList but better for frequent modifications


HashMap


Stores key-value pairs
Very fast access, insertion, and deletion
Best for: When you need to associate values with unique keys
Great for lookups and caching


HashSet


Collection of unique elements
Very fast checking for duplicates
Best for: When you need to ensure uniqueness of elements
Perfect for removing duplicates from a collection


Stack


Last-In-First-Out (LIFO) structure
Good for tracking state or processing nested structures
Best for: Undo/redo operations, parsing expressions, backtracking algorithms


Queue


First-In-First-Out (FIFO) structure
Good for processing elements in order
Best for: Task scheduling, breadth-first search, buffer management

Common Operations Time Complexity:
CopyData Structure | Access | Search | Insertion | Deletion
-------------------|--------|---------|----------|---------
Array         | O(1)   | O(n)   | O(n)      | O(n)
ArrayList     | O(1)   | O(n)   | O(n)      | O(n)
LinkedList    | O(n)   | O(n)   | O(1)      | O(1)
HashMap       | O(1)   | O(1)   | O(1)      | O(1)
HashSet       | N/A    | O(1)   | O(1)      | O(1)
Stack         | O(n)   | O(n)   | O(1)      | O(1)
Queue         | O(n)   | O(n)   | O(1)      | O(1)

Would you like me to explain any of these data structures in more detail or provide additional examples for specific use cases?

```java
/ 1. Arrays - Fixed-size collection of elements of the same type
public class ArrayExample {
    public static void main(String[] args) {
        // Declaring and initializing an array
        int[] numbers = new int[5];
        numbers[0] = 1;
        numbers[1] = 2;
        
        // Array literal
        String[] fruits = {"Apple", "Banana", "Orange"};
        
        // 2D Array
        int[][] matrix = {
            {1, 2, 3},
            {4, 5, 6}
        };
    }
}

// 2. ArrayList - Dynamic-size array
import java.util.ArrayList;

public class ArrayListExample {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        
        // Adding elements
        list.add("First");
        list.add("Second");
        
        // Accessing elements
        String first = list.get(0);
        
        // Removing elements
        list.remove(1);
        
        // Size
        int size = list.size();
    }
}

// 3. LinkedList - Doubly-linked list implementation
import java.util.LinkedList;

public class LinkedListExample {
    public static void main(String[] args) {
        LinkedList<Integer> linkedList = new LinkedList<>();
        
        // Adding elements
        linkedList.addFirst(1);  // Add at beginning
        linkedList.addLast(2);   // Add at end
        linkedList.add(3);       // Add at end
        
        // Removing elements
        linkedList.removeFirst();
        linkedList.removeLast();
    }
}

// 4. HashMap - Key-value pair storage
import java.util.HashMap;

public class HashMapExample {
    public static void main(String[] args) {
        HashMap<String, Integer> map = new HashMap<>();
        
        // Adding key-value pairs
        map.put("One", 1);
        map.put("Two", 2);
        
        // Getting values
        int value = map.get("One");
        
        // Checking if key exists
        boolean hasKey = map.containsKey("One");
        
        // Removing entries
        map.remove("Two");
    }
}

// 5. HashSet - Collection of unique elements
import java.util.HashSet;

public class HashSetExample {
    public static void main(String[] args) {
        HashSet<String> set = new HashSet<>();
        
        // Adding elements (duplicates are ignored)
        set.add("First");
        set.add("Second");
        set.add("First");  // Won't be added
        
        // Checking if element exists
        boolean exists = set.contains("First");
        
        // Removing elements
        set.remove("Second");
    }
}

// 6. Stack - LIFO (Last In First Out) data structure
import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        Stack<String> stack = new Stack<>();
        
        // Adding elements
        stack.push("Bottom");
        stack.push("Middle");
        stack.push("Top");
        
        // Viewing top element without removing
        String top = stack.peek();
        
        // Removing and returning top element
        String popped = stack.pop();
    }
}

// 7. Queue using LinkedList - FIFO (First In First Out)
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        
        // Adding elements
        queue.offer("First");
        queue.offer("Second");
        queue.offer("Third");
        
        // Viewing front element without removing
        String front = queue.peek();
        
        // Removing and returning front element
        String removed = queue.poll();
    }
}
```

 ![image](https://github.com/user-attachments/assets/d66f87df-bbe6-4f2f-825c-3ca2cd70dfaa)

*  Ref - > https://www.youtube.com/watch?v=DDRo29ptFwE

1. Array
   * Description: A fixed-size, indexed collection of elements.
   * Key Methods: Arrays are part of the core language, so they rely on standard array syntax.
```java
Example:
java
Copy code
int[] numbers = {1, 2, 3, 4, 5};
System.out.println("Element at index 2: " + numbers[2]); // Accessing an element
numbers[2] = 10; // Modifying an element
```

2. ArrayList
   * Description: A resizable array from the java.util package.
   * Key Methods: add(), get(), set(), remove(), size(), contains()
```java
Example:
java
Copy code
import java.util.ArrayList;

ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
System.out.println("List: " + list);
list.remove("Python");
System.out.println("Contains Java? " + list.contains("Java"));
```

3. LinkedList
   * Description: Doubly-linked list implementation of List and Deque.
   * Key Methods: addFirst(), addLast(), removeFirst(), removeLast(), getFirst(), getLast()
```java
Example:
java
Copy code
import java.util.LinkedList;

LinkedList<Integer> linkedList = new LinkedList<>();
linkedList.add(1);
linkedList.add(2);
linkedList.addFirst(0);
System.out.println("LinkedList: " + linkedList);
linkedList.removeLast();
System.out.println("After removal: " + linkedList);
```

4. HashMap
   * Description: A key-value pair mapping; part of Map.
   * Key Methods: put(), get(), remove(), containsKey(), containsValue(), keySet()
```java
Example:
java
Copy code
import java.util.HashMap;

HashMap<String, Integer> map = new HashMap<>();
map.put("Alice", 25);
map.put("Bob", 30);
System.out.println("Age of Alice: " + map.get("Alice"));
map.remove("Bob");
System.out.println("Contains Bob? " + map.containsKey("Bob"));
```

5. HashSet
   * Description: A collection that contains no duplicate elements.
   * Key Methods: add(), remove(), contains(), isEmpty(), size()
```java
Example:
java
Copy code
import java.util.HashSet;

HashSet<String> set = new HashSet<>();
set.add("Java");
set.add("Python");
set.add("Java"); // Duplicate ignored
System.out.println("Set: " + set);
System.out.println("Contains Python? " + set.contains("Python"));
```
6. Stack
   * Description: A last-in, first-out (LIFO) stack.
   * Key Methods: push(), pop(), peek(), isEmpty()
```java
Example:
java
Copy code
import java.util.Stack;

Stack<Integer> stack = new Stack<>();
stack.push(10);
stack.push(20);
System.out.println("Top Element: " + stack.peek());
stack.pop();
System.out.println("After pop: " + stack);
```

7. Queue
   * Description: A first-in, first-out (FIFO) collection.
   * Key Methods: add(), remove(), peek(), poll()
```java
Example:
java
Copy code
import java.util.LinkedList;
import java.util.Queue;

Queue<String> queue = new LinkedList<>();
queue.add("Alice");
queue.add("Bob");
System.out.println("Front Element: " + queue.peek());
queue.remove();
System.out.println("After removal: " + queue);
```
8. PriorityQueue
   * Description: A queue that orders elements based on natural ordering or a comparator.
   * Key Methods: add(), peek(), poll()
```java
Example:
java
Copy code
import java.util.PriorityQueue;

PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.add(5);
pq.add(2);
pq.add(8);
System.out.println("Top Element: " + pq.peek()); // Smallest element
pq.poll(); // Removes the smallest element
System.out.println("After poll: " + pq);
```
9. TreeSet
   Description: A sorted set based on a TreeMap.
   Key Methods: add(), remove(), first(), last(), contains()
```java
Example:
java
Copy code
import java.util.TreeSet;

TreeSet<Integer> treeSet = new TreeSet<>();
treeSet.add(10);
treeSet.add(5);
treeSet.add(20);
System.out.println("TreeSet: " + treeSet);
System.out.println("First Element: " + treeSet.first());
```
10. TreeMap
   * Description: A sorted map based on keys.
   * Key Methods: put(), get(), remove(), firstKey(), lastKey()
```java
Example:
java
Copy code
import java.util.TreeMap;

TreeMap<String, Integer> treeMap = new TreeMap<>();
treeMap.put("Alice", 25);
treeMap.put("Bob", 30);
System.out.println("First Key: " + treeMap.firstKey());
System.out.println("TreeMap: " + treeMap);
```
11. Deque (Double-Ended Queue)
     *  Description: A queue that allows insertion/removal from both ends.
     *  Key Methods: addFirst(), addLast(), removeFirst(), removeLast(), peekFirst(), peekLast()
```java       
Example:
java
Copy code
import java.util.ArrayDeque;
import java.util.Deque;

Deque<Integer> deque = new ArrayDeque<>();
deque.addFirst(10);
deque.addLast(20);
System.out.println("Deque: " + deque);
deque.removeFirst();
System.out.println("After removal: " + deque);
```
